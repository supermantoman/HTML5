@import url(./fonts.css);
@import url(./normalize.css);
@import url(./reset.css);

/* 숨김 콘텐츠 */
/* 보조기기에 접근한다 스크린리더 못읽게 하는게 display:none; 그래서 이 때는 쓰지 말 것! 존재해야만 DOM Tree 구조에서 읽을 수 있음! visability: hidden도 부적절. */
.a11y-hidden {
  background-color: red;
  
  /* 앱솔루트주면 혼자 떠있는 상태 */
  position: absolute;

  /* 안드로메다 ㄱㄱ로 숨기는 방식, 이렇게 하면 스크린리더가 읽을 수 있다! 화면에서는 안보이지만!!~ */
  top: -9999em;

  width: 1px;
  height: 1px;
  overflow: hidden;
  clip-path: polygon(0 0, 0 0, 0 0);
}

/* 기본 스타일 */
*, *::before, *::after{
  box-sizing: border-box;
}

/* 링크 스타일 */
a {
  color: inherit;
  text-decoration: none;
}

/* html에 폰트 기본값을 주고 그 다음 rem, em 으로 계산함 */
html {
  font-size: 10px;
} 

/* 본문 스타일 */
body {
 /* em, rem 단위를 사용해보기 */
font-size: 1.4rem;
color: #212121;
background: #ccc
  linear-gradient(to bottom, #ccc 0%, #eee 35%, #fff 70%, #fff 100%);
font-size: 1.4rem;
font-family: "Pretendard Variable", Pretendard, -apple-system,
  BlinkMacSystemFont, system-ui, Roboto, "Helvetica Neue", "Segoe UI",
  "Apple SD Gothic Neo", "Noto Sans KR", "Malgun Gothic", "Apple Color Emoji",
  "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
background: url("./images/bg_flower.png") no-repeat 50% 0,
  #ccc linear-gradient(to bottom, #ccc 0%, #eee 35%, #fff 70%, #fff 100%)
    repeat 0 0;
}

/* rem 단위는 무조건 루트를 기준으로 게산함. em 단위는  */

/* 레이아웃 */
.header, .visual, .main, .slogan, .footer-inner{
  width: 940px;
  margin: 0 auto;
}

/* 헤더 */
/* 높이는 가급적 실무에서 정해두지 않는 것이 좋다. */
/* 콘텐츠에 따라 유연하게 늘어날 수 있기 때문! */
.header {
  background: #fff;
  padding: 0 30px;
  border-radius: 0 0 15px 15px;
  position: relative;
}

/* 로고 */
.logo {
  position: absolute;
  top: 45px;
  left: 50px;
  z-index: 10;
}

/* 텍스트 링크 모음 */
.member {
  /* background-color: aqua; */
  text-align: right;
  padding: 4px 0;
  /* position 속성을 활용해 .member 영역을 오른쪽으로 10px 만큼 이동하는 방법
  position: relative; 
  /* 자기 자신 기준으로 움직임 */
  /* right: -10px; */
  transform: translateX(10px);
}

.member li {
  /* background-color: pink; */
  /* 가로방향으로 흘러가게끔 만들 수 있는 inline-block */
  display: inline-block;
}

.member a {
  /* background-color: coral; */
  padding: 6px 10px;
  display: inherit;
  text-transform: uppercase;
}

/* 마지막 li 요소에 포함된 a 요소를 선택해 오른쪽 padding 값을 0으로 재정의하는 방법이다. */
/* .member li:last-child a {
  padding-right: 0;
} */

.divider {
  margin-right: 30px;
}

/* 메인메뉴 */
.navigation {
  padding-bottom: 80px;
}

.menu {
  border-top: 2px solid currentColor;
  background: #e85e2c
    linear-gradient(
      to bottom,
      #ef9126 0%,
      #e85e2c 35%,
      #e85e2c 70%,
      #ef9126 100%
    );
  border-radius: 0 0 5px 5px;
  padding-left: 230px;
  height: 47px;
}

.menu > li:nth-child(-n + 3) {
  position: relative;
}

.menu-item {
  /* 안에있는 자식요소에 기준을 주기위해 relative 준다. */
  position: relative;
  float: left;
  border-left: 2px solid #fff;
}

.menu-html, .menu-css, .menu-standards {
  left: 0;
}

.menu-accessibility, .menu-qna, .menu-archive {
  right: 0;
}

.menu-button {
  border: 0;
  background: transparent;
  padding: 0 23px;
  line-height: 45px;
  font-size: 15px;
  font-weight: 700;
  color: #fff;
  text-shadow: 1px 1px 0 #000, -1px -1px 0 #000;
}

.is-active .menu-button {
  color: #ff0;
}

/* 가상선택자인 before, after은 content를 꼭 써야 나타남 */
/* 가상선택자는 인라인 속성을 가짐 */
.is-active .menu-button::after {
  /* content가 없으면 블록이 나타나지 않음. 그래서 입력 */
  content: "";
  /* 인라인속성(=같은라인에 포함되는 속성임)을 block으로 바꿔줌으로써 아래로 보내자 */
  display: block;
  /* 그리고 검정색 라인을 그려주기 */
  border-top: 2px solid #212121;
}

/* 비포나 애프터를 이용하면 무조건 인라인 속성으로 생성됨 */
/* float는 공간이 충분하지 않으면 밑으로 떨어짐 */
.sub-menu {
  position: absolute;
  top: 47px;
  display: none;
}

.is-active .sub-menu {
  display: block;
  white-space: nowrap;
}

.sub-menu li {
  display: inline-block;
  padding-left: 1em;
}

.sub-menu a::before {
  content: "\e802";
  font-family: "fontello";
  font-weight: normal;
  display: inline-block;
  text-decoration: inherit;
  width: 1em;
  margin-right: 0.2em;
  text-align: center;
  font-variant: normal;
  text-transform: none;
  line-height: 1em;
  margin-left: 0.2em;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.sub-menu a:hover::before,
.sub-menu a:focus::before {
  content: "\e801";
}

.sub-menu a {
  display: inline-block;
  padding: 10px 0;
}

.sub-menu a:hover, .sub-menu a:focus {
  color: red;
}

/* 비주얼 */

/* 키프레임 = animation 속성 부르기임. 그다음 함수 이름을 선언해주어야 한다. 
ex) moveEffect같이 카멜표현방식으로 표현하기. 걸맞는 이름을 생각해서 시나리오의 이름을 적어준다.
마치 씬의 이름을 정하듯이. 그리고 나서 필요한 디자인을 구현하기 위한 필요한 속성이 무엇인지 고민해보고 적어보기.
ex) 폰트가 1-확장(font-size), 2-해당위치로이동(transform_ 3-오퍼시티 투명에서 밝아지기(color:hsla) */
@keyframes moveEffect {
  0%{
    font-size: 12px;
    color: hsla(0, 0%, 0%, 0);
    transform: translate(0,0);
  }
  100%{
    font-size: 24px;
    color: hsla(0, 0%, 0%, 1);
    transform: translate(400px, 75px);
  }
}

@keyframes fadeEffect {
  0% {
    opacity: 1;
  }
  50% {
    opacity: 0;
  }
  /* 100% {
    opacity: 1; 없어졌다 다시 생기게 함 */
}

.visual{
  /* background: pink; */
  height: 120px;
  /* overflow: hidden; */
  position: relative;
}

.visual::before, .visual::after {
  content: "";
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  /* animation 요약 표기법은 아래 주석과 같음 */
  /* animation: fadeEffect 4000ms infinite alternate; */
  animation-name: fadeEffect; /* 위에 선언한 이름으로 불러주는 것 */
  animation-duration: 4000ms; /* 4초 */
  animation-iteration-count: infinite; /* 무한반복 속성임 */
  animation-direction: alternate;
  /* background-color: yellow; */
}

.visual::before {
  /* background-color: yellow; */
  /* ,로 구분해서 여러개의 이미지를 부를 수 있다. 폰트도 여러개 적용가능 순서대로. */
  background: url("./images/ani_flower_01.png") no-repeat 0 -10px,
              url(./images/ani_flower_02.png) no-repeat 600px 0;
}

.visual::after {
  /* background-color: #fff; */
  background: url("./images/ani_flower_03.png") no-repeat 300px 0,
              url(./images/ani_flower_04.png) no-repeat 800px 0;
  animation-delay: 3000ms;
}

.visual-text {
  /* background-color: #fff; */
  font-family: Georgia, 'Times New Roman', Times, serif;
  /* animation의 요약표기법은 아래, 순서는 상관없음, 일반적으로 이름과 듀레이션은 젤 앞 필수 */
  /* animation: moveEffect 400ms ease-in-out forwards; */
  animation-name: moveEffect;
  animation-duration: 400ms;
  animation-timing-function: ease-in-out;
  animation-fill-mode: forwards;
  /* 원래는 block인데 안튀어나가게 inline-block을 줌 */
  display: inline-block;
  /* position: absolute; */
}

/* 메인 */

.main{
  background: lightgreen;
  height: 50vh;
  display: flow-root;
  padding: 0 15px;
}

.group{
  margin: 0 15px;
  float: left;
}

.group1{
  background-color: violet;
  width: 250px;
}
.group2{
  background-color: salmon;
  width: 380px;
}
.group3{
  background-color: gold;
  width: 190px;
}

/* 슬로건 */
.slogan{
  background: skyblue;
  height: 10vh;
  clear: both;
}
/* 푸터 */
.footer{
  background: #ccc linear-gradient(to bottom, #ccc 0%, #eee 35%, #efefef 60%, #fff 100%);
}
.footer-inner{
  background: silver;
  height: 15vh;
  position: relative;
  top: -10px;
  left: -10px;
}

